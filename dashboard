#!/usr/bin/env python3
"""
å®æ—¶è®­ç»ƒç›‘æ§ä»ªè¡¨æ¿ (Real-time Training Dashboard)
====================================================
ä½¿ç”¨ Streamlit å®æ—¶å±•ç¤ºè®­ç»ƒè¿›åº¦ã€æŒ‡æ ‡ã€æ ·æœ¬åˆ†å¸ƒç­‰ä¿¡æ¯
"""

import json
import time
from pathlib import Path
from datetime import datetime, timedelta
import threading

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots


def load_metrics_history(monitor_dir: Path):
    """åŠ è½½æŒ‡æ ‡å†å²"""
    metrics_path = monitor_dir / "metrics_history.json"
    if metrics_path.exists():
        try:
            with open(metrics_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            st.error(f"åŠ è½½æŒ‡æ ‡å†å²å¤±è´¥: {e}")
            return []
    return []


def load_current_status(monitor_dir: Path):
    """åŠ è½½å½“å‰çŠ¶æ€"""
    status_path = monitor_dir / "current_status.json"
    if status_path.exists():
        try:
            with open(status_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            st.error(f"åŠ è½½å½“å‰çŠ¶æ€å¤±è´¥: {e}")
            return {}
    return {}


def create_metrics_chart(df):
    """åˆ›å»ºæ€§èƒ½æŒ‡æ ‡å›¾è¡¨"""
    if df.empty:
        return None
    
    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=("Dice åˆ†æ•°", "Precision åˆ†æ•°", "Recall åˆ†æ•°", "F1 åˆ†æ•°"),
        specs=[[{"secondary_y": False}, {"secondary_y": False}],
               [{"secondary_y": False}, {"secondary_y": False}]]
    )
    
    fig.add_trace(
        go.Scatter(x=df['round'], y=df['dice'], mode='lines+markers', 
                   name='Dice', line=dict(color='#1f77b4', width=2)),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(x=df['round'], y=df['precision'], mode='lines+markers',
                   name='Precision', line=dict(color='#ff7f0e', width=2)),
        row=1, col=2
    )
    
    fig.add_trace(
        go.Scatter(x=df['round'], y=df['recall'], mode='lines+markers',
                   name='Recall', line=dict(color='#2ca02c', width=2)),
        row=2, col=1
    )
    
    fig.add_trace(
        go.Scatter(x=df['round'], y=df['f1'], mode='lines+markers',
                   name='F1', line=dict(color='#d62728', width=2)),
        row=2, col=2
    )
    
    fig.update_xaxes(title_text="è½®æ¬¡", row=1, col=1)
    fig.update_yaxes(title_text="Dice", row=1, col=1, range=[0, 1])
    
    fig.update_xaxes(title_text="è½®æ¬¡", row=1, col=2)
    fig.update_yaxes(title_text="Precision", row=1, col=2, range=[0, 1])
    
    fig.update_xaxes(title_text="è½®æ¬¡", row=2, col=1)
    fig.update_yaxes(title_text="Recall", row=2, col=1, range=[0, 1])
    
    fig.update_xaxes(title_text="è½®æ¬¡", row=2, col=2)
    fig.update_yaxes(title_text="F1", row=2, col=2, range=[0, 1])
    
    fig.update_layout(height=800, showlegend=False, hovermode='x unified')
    return fig


def create_pseudo_label_chart(df):
    """åˆ›å»ºä¼ªæ ‡ç­¾å¢é•¿å›¾è¡¨"""
    if df.empty:
        return None
    
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=("ä¼ªæ ‡ç­¾æ€»æ•°å˜åŒ–", "æ¯è½®é€‰ä¸­æ ·æœ¬æ•°"),
        specs=[[{"secondary_y": False}, {"secondary_y": False}]]
    )
    
    fig.add_trace(
        go.Scatter(x=df['round'], y=df['pseudo_total'], mode='lines+markers',
                   name='ä¼ªæ ‡ç­¾æ€»æ•°', line=dict(color='#1f77b4', width=2),
                   fill='tozeroy'),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Bar(x=df['round'], y=df['selected'], name='æ¯è½®é€‰ä¸­',
               marker=dict(color='#ff7f0e')),
        row=1, col=2
    )
    
    fig.update_xaxes(title_text="è½®æ¬¡", row=1, col=1)
    fig.update_yaxes(title_text="æ•°é‡", row=1, col=1)
    
    fig.update_xaxes(title_text="è½®æ¬¡", row=1, col=2)
    fig.update_yaxes(title_text="æ•°é‡", row=1, col=2)
    
    fig.update_layout(height=400, showlegend=True, hovermode='x unified')
    return fig


def create_confidence_chart(df):
    """åˆ›å»ºç½®ä¿¡åº¦åˆ†å¸ƒå›¾è¡¨"""
    if df.empty:
        return None
    
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(
        x=df['round'], y=df['avg_confidence'],
        mode='lines+markers',
        name='å¹³å‡ç½®ä¿¡åº¦',
        line=dict(color='#2ca02c', width=2),
        marker=dict(size=8),
        fill='tozeroy'
    ))
    
    fig.update_layout(
        title="LLM è¯„åˆ†ç½®ä¿¡åº¦è¶‹åŠ¿",
        xaxis_title="è½®æ¬¡",
        yaxis_title="ç½®ä¿¡åº¦ (0-100)",
        height=400,
        hovermode='x unified',
        template='plotly_white'
    )
    
    return fig


def create_sample_chart(df):
    """åˆ›å»ºæ ·æœ¬æŠ½å–åˆ†å¸ƒå›¾è¡¨"""
    if df.empty:
        return None
    
    fig = go.Figure()
    
    fig.add_trace(go.Bar(
        x=df['round'], y=df['sampled'],
        name='æŠ½å–æ•°é‡',
        marker=dict(color='#1f77b4')
    ))
    
    fig.add_trace(go.Scatter(
        x=df['round'], y=df['selected'],
        name='é€‰ä¸­æ•°é‡',
        mode='lines+markers',
        line=dict(color='#d62728', width=2),
        yaxis='y2'
    ))
    
    fig.update_layout(
        title="æ ·æœ¬æŠ½å–ä¸é€‰ä¸­æƒ…å†µ",
        xaxis_title="è½®æ¬¡",
        yaxis_title="æŠ½å–æ•°é‡",
        yaxis2=dict(title="é€‰ä¸­æ•°é‡", overlaying="y", side="right"),
        height=400,
        hovermode='x unified',
        template='plotly_white'
    )
    
    return fig


def main():
    st.set_page_config(
        page_title="è®­ç»ƒç›‘æ§ä»ªè¡¨æ¿",
        page_icon="ğŸ“Š",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    st.title("ğŸš€ åŒ»å­¦å›¾åƒåˆ†å‰² - å®æ—¶è®­ç»ƒç›‘æ§ä»ªè¡¨æ¿")
    
    # ä»å‘½ä»¤è¡Œå‚æ•°æˆ–ç¯å¢ƒå˜é‡è·å–é»˜è®¤ work_root
    import sys
    default_work_root = "./work"
    if len(sys.argv) > 1:
        # æ£€æŸ¥æ˜¯å¦æœ‰ --work-root å‚æ•°
        for i, arg in enumerate(sys.argv):
            if arg == "--work-root" and i + 1 < len(sys.argv):
                default_work_root = sys.argv[i + 1]
                break
    
    with st.sidebar:
        st.header("âš™ï¸ é…ç½®")
        work_root = st.text_input(
            "å·¥ä½œæ ¹ç›®å½•",
            value=default_work_root,
            help="è®­ç»ƒå·¥ä½œç›®å½•è·¯å¾„"
        )
        
        monitor_dir = Path(work_root) / "monitor"
        
        auto_refresh = st.checkbox("è‡ªåŠ¨åˆ·æ–°", value=True, help="å¯ç”¨è‡ªåŠ¨åˆ·æ–° (5ç§’)")
        if auto_refresh:
            st.info("é¡µé¢å°†æ¯5ç§’è‡ªåŠ¨åˆ·æ–°ä¸€æ¬¡")
    
    if not Path(work_root).exists():
        st.error(f"âŒ å·¥ä½œç›®å½•ä¸å­˜åœ¨: {work_root}")
        st.stop()
    
    if not monitor_dir.exists():
        st.warning(f"â³ ç›‘æ§ç›®å½•ä¸å­˜åœ¨ï¼Œç­‰å¾…è®­ç»ƒå¼€å§‹...")
        st.info(f"é¢„æœŸè·¯å¾„: {monitor_dir}")
        st.stop()
    
    # åŠ è½½æ•°æ®
    metrics_history = load_metrics_history(monitor_dir)
    current_status = load_current_status(monitor_dir)
    
    # é¡¶éƒ¨çŠ¶æ€å¡ç‰‡
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        current_round = current_status.get('current_round', 0)
        max_rounds = current_status.get('max_rounds', 0)
        st.metric(
            "ğŸ“ å½“å‰è½®æ¬¡",
            f"{current_round}/{max_rounds}",
            delta=f"{current_round}" if current_round > 0 else None
        )
    
    with col2:
        best_dice = current_status.get('best_dice', 0)
        st.metric(
            "ğŸ¯ æœ€ä½³ Dice",
            f"{best_dice:.4f}",
            delta=f"Round {current_status.get('best_round', 0)}" if best_dice > 0 else None
        )
    
    with col3:
        pseudo_count = current_status.get('pseudo_count', 0)
        st.metric(
            "ğŸ·ï¸ ä¼ªæ ‡ç­¾æ•°é‡",
            f"{pseudo_count}",
            delta=f"+{pseudo_count}" if pseudo_count > 0 else None
        )
    
    with col4:
        remaining_images = current_status.get('remaining_images', 0)
        st.metric(
            "ğŸ“¦ å‰©ä½™æœªæ ‡æ³¨",
            f"{remaining_images}",
            delta=f"-{remaining_images}" if remaining_images >= 0 else None
        )
    
    with col5:
        last_update = current_status.get('last_update')
        if last_update:
            last_update_time = datetime.fromisoformat(last_update)
            time_ago = datetime.now() - last_update_time
            if time_ago.total_seconds() < 60:
                status_text = f"{int(time_ago.total_seconds())}ç§’å‰"
            else:
                status_text = f"{int(time_ago.total_seconds() / 60)}åˆ†é’Ÿå‰"
            st.metric("ğŸ• æœ€åæ›´æ–°", status_text)
        else:
            st.metric("ğŸ• æœ€åæ›´æ–°", "æœªæ›´æ–°")
    
    st.divider()
    
    # å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œæç¤ºç”¨æˆ·
    if not metrics_history:
        st.info("â³ ç­‰å¾…ç¬¬ä¸€è½®è®­ç»ƒå®Œæˆ... ç›‘æ§æ•°æ®å°†åœ¨æ­¤æ˜¾ç¤º")
        if auto_refresh:
            time.sleep(5)
            st.rerun()
        st.stop()
    
    # è½¬æ¢ä¸º DataFrame
    df = pd.DataFrame(metrics_history)
    
    # åˆ›å»ºæ ‡ç­¾é¡µ
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡", 
        "ğŸ·ï¸ ä¼ªæ ‡ç­¾ç®¡ç†", 
        "ğŸ’¯ ç½®ä¿¡åº¦åˆ†æ", 
        "ğŸ“Š æ ·æœ¬åˆ†æ",
        "ğŸ“‹ è¯¦ç»†æ•°æ®"
    ])
    
    with tab1:
        st.subheader("æ€§èƒ½æŒ‡æ ‡å˜åŒ–")
        st.info("å±•ç¤º Diceã€Precisionã€Recallã€F1 å››ä¸ªå…³é”®æŒ‡æ ‡çš„å˜åŒ–è¶‹åŠ¿")
        
        fig = create_metrics_chart(df)
        if fig:
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.warning("æ•°æ®ä¸è¶³")
    
    with tab2:
        st.subheader("ä¼ªæ ‡ç­¾å¢é•¿ä¸æ ·æœ¬é€‰æ‹©")
        st.info("å±•ç¤ºä¼ªæ ‡ç­¾é›†åˆçš„å¢é•¿æƒ…å†µå’Œæ¯è½®é€‰ä¸­çš„æ ·æœ¬æ•°")
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            fig = create_pseudo_label_chart(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.metric("æ€»ä¼ªæ ‡ç­¾æ•°", df['pseudo_total'].iloc[-1] if not df.empty else 0)
            st.metric("æ€»é€‰ä¸­æ ·æœ¬", df['selected'].sum() if not df.empty else 0)
            st.metric("å¹³å‡é€‰ä¸­ç‡", f"{(df['selected'].sum() / df['sampled'].sum() * 100):.1f}%" if df['sampled'].sum() > 0 else "0%")
    
    with tab3:
        st.subheader("LLM è¯„åˆ†ç½®ä¿¡åº¦åˆ†æ")
        st.info("å±•ç¤º LLM Vision API ç»™å‡ºçš„å¹³å‡ç½®ä¿¡åº¦è¶‹åŠ¿")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            fig = create_confidence_chart(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            st.metric("æœ€é«˜ç½®ä¿¡åº¦", f"{df['avg_confidence'].max():.2f}")
            st.metric("æœ€ä½ç½®ä¿¡åº¦", f"{df['avg_confidence'].min():.2f}")
            st.metric("å¹³å‡ç½®ä¿¡åº¦", f"{df['avg_confidence'].mean():.2f}")
    
    with tab4:
        st.subheader("æ ·æœ¬æŠ½å–åˆ†æ")
        st.info("å±•ç¤ºæ¯è½®çš„æ ·æœ¬æŠ½å–æ•°é‡å’Œæœ€ç»ˆé€‰ä¸­æ•°é‡")
        
        col1, col2 = st.columns([3, 1])
        
        with col1:
            fig = create_sample_chart(df)
            if fig:
                st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            total_sampled = df['sampled'].sum()
            total_selected = df['selected'].sum()
            st.metric("æ€»æŠ½å–æ ·æœ¬", total_sampled)
            st.metric("æ€»é€‰ä¸­æ ·æœ¬", total_selected)
            st.metric("é€‰ä¸­ç‡", f"{(total_selected / total_sampled * 100):.1f}%" if total_sampled > 0 else "0%")
    
    with tab5:
        st.subheader("è¯¦ç»†æŒ‡æ ‡æ•°æ®è¡¨")
        st.info("æ‰€æœ‰è½®æ¬¡çš„è¯¦ç»†æŒ‡æ ‡æ•°æ®")
        
        # ä¿ç•™æ—¶é—´æˆ³ä»¥ä¾¿æ˜¾ç¤º
        display_df = df.copy()
        if 'timestamp' in display_df.columns:
            display_df['timestamp'] = pd.to_datetime(display_df['timestamp']).dt.strftime('%Y-%m-%d %H:%M:%S')
        
        # é‡æ–°æ’åˆ—åˆ—é¡ºåº
        col_order = ['round', 'sampled', 'selected', 'avg_confidence', 'pseudo_total', 
                     'dice', 'precision', 'recall', 'f1', 'is_best']
        available_cols = [col for col in col_order if col in display_df.columns]
        if 'timestamp' in display_df.columns:
            available_cols.append('timestamp')
        
        display_df = display_df[available_cols]
        
        st.dataframe(
            display_df,
            use_container_width=True,
            hide_index=True,
            column_config={
                'round': st.column_config.NumberColumn('è½®æ¬¡', format='%d'),
                'sampled': st.column_config.NumberColumn('æŠ½å–', format='%d'),
                'selected': st.column_config.NumberColumn('é€‰ä¸­', format='%d'),
                'avg_confidence': st.column_config.NumberColumn('ç½®ä¿¡åº¦', format='%.2f'),
                'pseudo_total': st.column_config.NumberColumn('ä¼ªæ ‡ç­¾æ€»æ•°', format='%d'),
                'dice': st.column_config.NumberColumn('Dice', format='%.4f'),
                'precision': st.column_config.NumberColumn('Precision', format='%.4f'),
                'recall': st.column_config.NumberColumn('Recall', format='%.4f'),
                'f1': st.column_config.NumberColumn('F1', format='%.4f'),
                'is_best': st.column_config.CheckboxColumn('æœ€ä½³æ¨¡å‹'),
                'timestamp': st.column_config.TextColumn('æ—¶é—´æˆ³')
            }
        )
    
    st.divider()
    
    # é¡µè„šä¿¡æ¯
    col1, col2, col3 = st.columns(3)
    with col1:
        st.caption("ğŸ“ å·¥ä½œç›®å½•: " + str(work_root))
    with col2:
        if current_status:
            progress_pct = (current_round / max_rounds * 100) if max_rounds > 0 else 0
            st.caption(f"â±ï¸ è¿›åº¦: {progress_pct:.1f}%")
        else:
            st.caption("â±ï¸ è¿›åº¦: 0%")
    with col3:
        st.caption("ğŸ”„ è‡ªåŠ¨åˆ·æ–°: " + ("âœ“" if auto_refresh else "âœ—"))
    
    # è‡ªåŠ¨åˆ·æ–°
    if auto_refresh:
        time.sleep(5)
        st.rerun()


if __name__ == "__main__":
    main()
